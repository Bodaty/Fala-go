/*
 * flow/access/access.proto
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: version not set
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"net/http"

	"github.com/gorilla/mux"
	accessproto "github.com/onflow/flow/protobuf/go/flow/access"
)

func AccessAPIExecuteScriptAtBlockID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIExecuteScriptAtLatestBlock(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetAccountAtBlockHeight(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetBlockByHeight(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetBlockByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetBlockHeaderByHeight(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetBlockHeaderByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetCollectionByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetEventsForBlockIDs(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetLatestProtocolStateSnapshot(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetNetworkParameters(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetTransaction(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func AccessAPIGetTransactionResult(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	// w.WriteHeader(http.StatusOK)

	params := mux.Vars(r)
	txId := params["id"]

	// TODO: convert hex string to bytes
	// message GetTransactionRequest { bytes id = 1; }
	// message TransactionResponse { entities.Transaction transaction = 1; }
	txIdBytes, err := hex.DecodeString(txId)
	if err != nil {
		// TODO: invalid transactionId, should return 400 and error message to user
		w.WriteHeader(http.StatusBadRequest)
		panic(err)
	}
	// fmt.Printf("% x", data)

	// Assume we have a client to the gRPC server
	// TODO: actually, we should use the handler directly
	transactionResponse, err := client.GetTransactionResult(context.Background(), &accessproto.GetTransactionRequest{txIdBytes})
	if err != nil {
		// TODO: propagate error message to user?
	}

	// we want to convert transaction to proper JSON format
	// from:

	// type Transaction struct {
	// 	Script               []byte                   `protobuf:"bytes,1,opt,name=script,proto3" json:"script,omitempty"`
	// 	Arguments            [][]byte                 `protobuf:"bytes,2,rep,name=arguments,proto3" json:"arguments,omitempty"`
	// 	ReferenceBlockId     []byte                   `protobuf:"bytes,3,opt,name=reference_block_id,json=referenceBlockId,proto3" json:"reference_block_id,omitempty"`
	// 	GasLimit             uint64                   `protobuf:"varint,4,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// 	ProposalKey          *Transaction_ProposalKey `protobuf:"bytes,5,opt,name=proposal_key,json=proposalKey,proto3" json:"proposal_key,omitempty"`
	// 	Payer                []byte                   `protobuf:"bytes,6,opt,name=payer,proto3" json:"payer,omitempty"`
	// 	Authorizers          [][]byte                 `protobuf:"bytes,7,rep,name=authorizers,proto3" json:"authorizers,omitempty"`
	// 	PayloadSignatures    []*Transaction_Signature `protobuf:"bytes,8,rep,name=payload_signatures,json=payloadSignatures,proto3" json:"payload_signatures,omitempty"`
	// 	EnvelopeSignatures   []*Transaction_Signature `protobuf:"bytes,9,rep,name=envelope_signatures,json=envelopeSignatures,proto3" json:"envelope_signatures,omitempty"`
	// 	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	// 	XXX_unrecognized     []byte                   `json:"-"`
	// 	XXX_sizecache        int32                    `json:"-"`
	// }

	// to:

	// type EntitiesTransaction struct {
	// 	Script string `json:"script,omitempty"`
	// 	Arguments []string `json:"arguments,omitempty"`
	// 	ReferenceBlockId string `json:"referenceBlockId,omitempty"`
	// 	GasLimit string `json:"gasLimit,omitempty"`
	// 	ProposalKey *TransactionProposalKey `json:"proposalKey,omitempty"`
	// 	Payer string `json:"payer,omitempty"`
	// 	Authorizers []string `json:"authorizers,omitempty"`
	// 	PayloadSignatures []TransactionSignature `json:"payloadSignatures,omitempty"`
	// 	EnvelopeSignatures []TransactionSignature `json:"envelopeSignatures,omitempty"`
	// }

	payload := responseConverters.convertTransactionResponse(transactionResponse)

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(payload)
}

func AccessAPISendTransaction(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}
